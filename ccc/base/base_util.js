// The Cmacs Project.

/** @fileoverview This provides utility functions for use by base library
 * implementation code.
 */

goog.provide('ccc.baseUtil');

goog.require('ccc.core');
goog.require('goog.object');



/**
 * Generates a simple NativeProcedure from a simplified procedure specification.
 * This provides a declarative means of configurating argument arity and type-
 * checking and returning direct values rather than dealing with continuation-
 * passing.
 *
 * Within the spec's implementation function, |this| is bound to an object with
 * fields referencing the current environment, continuation, and raw argument
 * list.
 *
 * @param {ccc.baseUtil.SimpleProcedureSpec} spec
 */
ccc.baseUtil.registerProcedure = function(namespace, name, spec) {
  namespace[name] = new ccc.NativeProcedure(function(
      environment, args, continuation) {
    var argList = [];
    var argIndex = 0;
    var arg = args;
    if (goog.isDef(spec.args)) {
      for (var i = 0; i < spec.args.length; ++i) {
        if (!ccc.isPair(arg))
          return continuation(new ccc.Error(name + ': Not enough arguments'));
        var predicate = spec.args[i];
        if (!goog.isNull(predicate) && !predicate(arg.car()))
          return continuation(new ccc.Error(name +
              ': Incorrect type for argument ' + (argIndex + 1)));
        argList[argIndex++] = arg.car();
        arg = arg.cdr();
      }
    }
    if (goog.isDef(spec.optionalArgs)) {
      if (spec.optionalArgs instanceof Array) {
        for (var i = 0; i < spec.optionalArgs.length; ++i) {
          if (!ccc.isPair(arg))
            break;
          var predicate = spec.optionalArgs[i];
          if (!goog.isNull(predicate) && !predicate(arg.car()))
            return continuation(new ccc.Error(name +
                ': Incorrect type for argument ' + (argIndex + 1)));
          argList[argIndex++] = arg.car();
          arg = arg.cdr();
        }
      } else if (spec.optionalArgs instanceof Function ||
                 goog.isNull(spec.optionalArgs)) {
        var predicate = spec.optionalArgs;
        while (ccc.isPair(arg)) {
          if (!goog.isNull(predicate) && !predicate(arg.car()))
            return continuation(new ccc.Error(name +
                ': Incorrect type for argument ' + (argIndex + 1)));
          argList[argIndex++] = arg.car();
          arg = arg.cdr();
        }
      }
    }
    if (!ccc.isNil(arg))
      return continuation(new ccc.Error(name + ': Too many arguments'));
    var context = {
      environment: environment,
      args: args,
      continuation: continuation,
    };
    var result = spec.impl.apply(context, argList);
    if (!goog.isDef(result))
      result = ccc.UNSPECIFIED;
    if (!!spec.thunk)
      return /** @type {ccc.Thunk} */ (result);
    return continuation(/** @type {ccc.Data} */ (result));
  });
};


/**
 * Argument type validation predicate.
 *
 * @typedef {function(ccc.Data):boolean}
 * @private
 */
var TypePredicate_;


/**
 * Specification for a simple native procedure.
 *
 * If |args| is given it must be an Array, and each element is used as a type-
 * checking predicate for the argument in the corresponding position. If a
 * predicate is {@code null}, no automatic type-checking is done by the
 * generated procedure.
 *
 * The length of |args| determines the arity of the procedure. If |optionalArgs|
 * is unspecified, this is the exact arity; otherwise it's the minimum arity.
 *
 * |optionalArgs| may also be an Array, in which case the procedure takes a
 * finite number of optional arguments. If |args| is length N and |optionalArgs|
 * is length |M|, the procedure has an arity range of [N, N+M].
 *
 * If |optionalArgs| is a predicate or {@code null}, the procedure can take
 * any number of arguments which match the predicate. If {@code null}, the
 * procedure can take any number of arguments of any type.
 *
 * If |thunk| is {@code true} (default {@code false}), then the function
 * provided by |impl| must return a {@code ccc.Thunk} to continue computation.
 * If {@code false}, |impl| instead returns any {@code ccc.Data}, and
 * computation will continue in the thunk generated by passing data to the
 * calling continuation. IF |impl| returns {@code undefined}, it is converted
 * to {@code ccc.UNSPECIFIED} implicitly.
 *
 * Arguments when calling |impl| are destructured from their list form and
 * applied as real JS function arguments.
 *
 * @typedef {{
 *   args: (!Array.<?TypePredicate_>|undefined),
 *   optionalArgs: (!Array.<?TypePredicate_>|?TypePredicate_|undefined),
 *   thunk: (boolean|undefined),
 *   impl: (function(this:ccc.baseUtil.ProcedureContext, *):*)
 * }}
 */
ccc.baseUtil.SimpleProcedureSpec;


/**
 * Context to which |this| is bound within baseUtil-generated procedure
 * implementations.
 *
 * |environment| is the calling environment.
 * |args| is the raw list of arguments provided by the caller.
 * |continuation| is the current (calling) continuation.
 *
 * @typedef {{
 *   environment: (!ccc.Environment),
 *   args: (!ccc.Pair|!ccc.Nil),
 *   continuation: (ccc.Continuation)
 * }}
 */
ccc.baseUtil.ProcedureContext;


/**
 * Creates multiple simple procedure bindings given a mapping from name to
 * procedure spec.
 *
 * @param {!Object.<string, ccc.baseUtil.SimpleProcedureSpec>} specMap
 */
ccc.baseUtil.registerProcedures = function(namespace, specMap) {
  goog.object.forEach(specMap, function(spec, name) {
    ccc.baseUtil.registerProcedure(namespace, name, spec);
  });
};
